//! # Perk generation
//! Perks are generated in a fairly complex manner.
//!
//! In the following code, `random(x, y)` generates an integer between x and y-1, inclusive of both. `floor(x)` rounds
//! down x to the nearest integer.
//!
//! First, some background data. Each material has a selection of perks it can give, and each of those perks have two
//! associated numbers - a fixed part (`base`) and a random part (`roll`). These numbers differ between materials for the
//! same perks. For example: for the [Precise](https://runescape.wiki/w/Precise) perk,
//! [Precise components](https://runescape.wiki/w/Precise_components) have a base of 9 and a roll of 32;
//! [Armadyl components](https://runescape.wiki/w/Armadyl_components) have a base of 44 and a roll of 8.
//!
//! Ancient components are exclusive to [ancient gizmos](https://runescape.wiki/w/Ancient_gizmo) and cannot be used in
//! normal gizmo shells (these have the value of `ancient_only` set to `true` in our [data file](../data.json)). When we
//! use a material other than ancient components inside of an ancient gizmo, the aforementioned `base` and `roll` values for
//! that material's possible perks are multiplied by 80%.
//!
//! Additionally, each perk has a number of ranks, and each rank has two associated numbers - a rank threshold
//! (`threshold`), and a rank value (`cost`). For example, the Precise perk has thresholds 50, 80, 130, 170, 210, and values
//! 35, 65, 120, 160, 195, corresponding to each of the 5 ranks.
//!
//! 1. Generate the invent budget. This is calculated by summing 5 rolls of `random(0, floor(invention level / 2) + 20)`
//!    (that means 5 separate random rolls; includes boosts to Invention level). If using an ancient gizmo, an additional
//!    roll (a total of 6) is performed.
//!        - If invent budget is below your Invention level, set it to your Invention level.
//! 2. Calculate the perk values for each perk that can be generated by the input materials. Keep track of perks
//!    available in an array; add this to the array in order of the materials, iterating the slots in order middle, top,
//!    left, right, bottom (along with top-left, top-right, bottom-left, and bottom-right if using an ancient gizmo).
//!    This is done by calculating base + random(0, roll) for each material and each perk, summing the values if multiple
//!    materials use the same perk.
//! 3. Calculate the rank generated by finding the largest rank threshold that the corresponding perk value is greater
//!    than or equal to. If the perk value is less than the lowest rank threshold for a given perk, then set the rank to 0
//!    with a cost of 0. These perks cannot be generated, however must still be included at this point as it affects the
//!    operation of the following sorting algorithm.
//! 4. Sort the perks in ascending order of rank cost (lowest value first) using a modified quicksort algorithm (see below).
//! 5. For each perk in the sorted perk values, in reverse order:
//!        - If the current invent budget is less than or equal to the rank cost, move on to the next perk.
//!        - If invent budget is strictly greater than the rank cost, this perk-rank combination is generated. Subtract
//!          the rank cost from invent budget and continue to the next perk with the new invent budget.
//! 6. Once you have generated 2 perks, or ran out of perks to check, we are done.
//!        - If either one of the perks generated was a two-slot perk (Enhanced Devoted or Enhanced Efficient), set the
//!          second perk generated to nothing.
//!        - If you generated no perks, the gizmo shell and the materials are not consumed.
//!
//! ## Sorting
//!
//! Sorting of the perk array by `rank cost` is done by a modified [quicksort](https://en.wikipedia.org/wiki/Quicksort)
//! algorithm. How this sort breaks ties is extremely important and slight differences in the method can make massive
//! differences in what perks are generated. This is also why the array is sorted into ascending order then iterated
//! backwards, rather than sorted into descending order and iterated forwards.
//!
//! It is easier to provide an implementation of the sort than describe it - since it is mostly quicksort, you can see
//! the above linked wikipedia page for it. Here is a javascript implementation of the sort, as is used by the
//! [calculator on the wiki](https://runescape.wiki/w/Calculator:Perks).
//!
//! ```js
//!  /**
//!  * Sorts an array in-place
//!  * compare(x,y) should be a function that returns a positive number if x>y, a negative number if x<y, and 0 if x=y - the easiest way to do that is return x-y
//!  */
//! function quicksort(low, high, arr, compare) {
//! 	var pivot_index = (~~((low + high)/2)); // floor division
//! 	var pivot_value = arr[pivot_index];
//! 	arr[pivot_index] = arr[high];
//! 	arr[high] = pivot_value;
//! 	var counter = low;
//! 	var loop_index = low;
//!
//! 	while (loop_index < high) {
//! 		if (compare(arr[loop_index], pivot_value) < (loop_index & 1)) {
//! 			var tmp = arr[loop_index];
//! 			arr[loop_index] = arr[counter];
//! 			arr[counter] = tmp;
//! 			counter = counter + 1;
//! 		}
//! 		loop_index = loop_index + 1;
//! 	}
//!
//! 	arr[high] = arr[counter];
//! 	arr[counter] = pivot_value;
//!
//! 	if (low < (counter - 1)) {
//! 		quicksort(low, counter - 1, arr, compare);
//! 	}
//! 	if ((counter + 1) < high) {
//! 		quicksort(counter + 1, high, arr, compare);
//! 	}
//! }
//! // example use
//! var perkArr = [
//! 	{'perk': 'Cautious', 'cost': 0, 'probability': 0.0019369834710743802, 'rank': 0},
//! 	{'perk': 'Blunted', 'cost': 0, 'probability': 0.00021947873799725651, 'rank': 0},
//! 	{'perk': 'Equilibrium', 'cost': 0, 'probability': 0.11297548487631127, 'rank': 0},
//! 	{'perk': 'Precise', 'cost': 65, 'probability': 0.00510406494140625, 'rank': 2},
//! 	{'perk': 'Flanking', 'cost': 0, 'probability': 0.013885498046875, 'rank': 0}
//! ];
//! quicksort(0, (perkArr.length - 1), perkArr, function (x, y) { return x.cost - y.cost });
//! // sorts into order Blunted, Equilibrium, Flanking, Cautious, Precise
//! ```
//!
//! The most notable line is the comparison - `compare(arr[loop_index], pivot_value) < (loop_index & 1)`. In the game code,
//! the comparison alternates with loop_index between `< 0` and `<= 0`, which we emulate by the bitwise AND
//! (`loop_indexÂ % 2` has the same effect) to make the comparison `< 0` and `< 1`.

pub mod definitions;
pub mod utils;
pub mod dice;
pub mod perk_values;
pub mod gizmo_cost_thresholds;
use definitions::*;
use itertools::Itertools;
use std::{cmp, fs};

pub fn load_data() -> Data {
    let data = fs::read_to_string("data.json").unwrap();
    serde_json::from_str(&data).unwrap()
}

#[allow(unused_variables, dead_code, unused_mut)]
pub fn perk_solver(args: &Args, data: &Data, wanted_gizmo: &Gizmo) {
    let materials = get_materials(&args, &data, &wanted_gizmo);
    let materials = split_materials(&args, &data, &wanted_gizmo, materials);
    let budgets = generate_budgets(&args);
    let slot_count = if args.ancient { 9 } else { 5 };

    let total_combination_count = calc_combination_count(materials.conflict.len(), materials.no_conflict.len(), args.ancient);
    let mut count = 0;
    let mut total_gizmos_generated = 0;

    println!("{:#?}", materials);
    println!("# combinations: {}", utils::format_int(total_combination_count as i64));

    for n_mats_used in 1..slot_count {
        // Order does no matter when none of the materials used have a cost conflict with the wanted perks
        for mat_combination in materials.no_conflict.iter().copied().combinations_with_replacement(n_mats_used) {
            calc_gizmo_probabilities(&data, &args, &budgets, &mat_combination, &wanted_gizmo);
        }
    }
}

fn get_materials(args: &Args, data: &Data, wanted_gizmo: &Gizmo) -> Vec<MaterialName> {
    let mut possible_materials = Vec::new();

    for (mat_name, mat_data) in data.comps.iter() {
        for comp_values in mat_data[args.gizmo_type].iter() {
            if (comp_values.perk == wanted_gizmo.perks.0.perk || comp_values.perk == wanted_gizmo.perks.1.perk)
            && (args.ancient || !mat_data.ancient_only) {
                possible_materials.push(*mat_name);
            }
        }
    }

    let possible_materials: Vec<_>= possible_materials.iter().unique().sorted().filter(|x| {
        !args.exclude.iter().any(|y| { x.to_string().to_lowercase().contains(&y.to_lowercase()) })
    }).copied().collect();

    if possible_materials.len() == 0 {
        utils::print_error("No materials found that can produce this perk.")
    }

    possible_materials
}

/// Splits material into two groups: conflict and non-conflict materials.
///
/// Conflict materials are materials that can generate perks with an equal cost value as one of the wanted perk ranks.
/// This matters as equal cost values can cause unstable sorting results so for these material combinations the order
/// of the materials if important whereas gizmos made entirely from non-conflict materials are position independent.
fn split_materials(args: &Args, data: &Data, wanted_gizmo: &Gizmo, mats: Vec<MaterialName>) -> SplitMaterials {
    let mut conflict = Vec::new();
    let mut no_conflict = Vec::new();

    let cost_p1 = data.perks[&wanted_gizmo.perks.0.perk].ranks[wanted_gizmo.perks.0.rank as usize].cost;
    let cost_p2 = if wanted_gizmo.perks.1.perk != PerkName::Empty {
        data.perks[&wanted_gizmo.perks.1.perk].ranks[wanted_gizmo.perks.1.rank as usize].cost
    } else {
        0
    };

    for mat in mats.iter() {
        let mut is_conflict = false;
        'comp: for comp_values in data.comps[mat][args.gizmo_type].iter() {
            if comp_values.perk != wanted_gizmo.perks.0.perk && comp_values.perk != wanted_gizmo.perks.1.perk {
                for perk_rank in data.perks[&comp_values.perk].ranks.iter() {
                    if perk_rank.rank > 0 && (perk_rank.cost == cost_p1 || perk_rank.cost == cost_p2) {
                        conflict.push(*mat);
                        is_conflict = true;
                        break 'comp;
                    }
                }
            }
        }

        if !is_conflict {
            no_conflict.push(*mat);
        }
    }

    SplitMaterials { conflict, no_conflict }
}

/// Each budget is a cumulative probability distribution for the invention level related random rolls.
fn generate_budgets(args: &Args) -> Vec<Budget> {
    let rolls = if args.ancient { 6 } else { 5 };
    let (low, high) = if args.invention_level.len() == 1 {
        (args.invention_level[0], args.invention_level[0])
    } else {
        (args.invention_level[0], args.invention_level[1])
    };
    let mut budgets = Vec::new();

    for lvl in (low..=high).step_by(2) {
        let dist = dice::get_cumulative_distribution(lvl as usize / 2 + 20, rolls as usize);
        let max = dist.len() - 1;
        let budget = Budget {
            dist,
            level: lvl as u16,
            range: Range {
                min: lvl as u16,
                max: max as u16
            }
        };
        budgets.push(budget);
    }

    budgets
}

/// Calculate how many material combination there are so we can show a progress bar.
///
/// This calculation is made up of two parts because materials are split in conflict and no-conflict types. If a
/// combination of materials only contains no-conflict materials then the order of the materials doesn't matter. As
/// soon as the combination contains at least one conflict material then we can't be certain that order doesn't matter
/// so we have to check every order. But it's only the order of first occurrence that matters so the pattern abbc is the
/// same as abcb. The order of the repeated materials also doesn't matter so abcbc is the same as abccb.
fn calc_combination_count(conflict_size: usize, no_conflict_size: usize, is_ancient: bool) -> usize {
    let slot_count = if is_ancient { 9 } else { 5 };
    let mut count = 0;

    // Factorial operator (https://en.wikipedia.org/wiki/Factorial)
    fn fac(n: usize) -> usize {
        let mut r = 1;
        for i in 2..=n {
            r *= i;
        }
        r
    }

    for i in 1..=slot_count {
        count += dice::choose(no_conflict_size + i - 1, i) as usize; // Combination with repetition

        for j in 1..=cmp::min(i, conflict_size) {
            let mut x = 0;
            for k in 0..=cmp::min(i - j, no_conflict_size) {
                x += dice::choose(no_conflict_size, k) as usize * fac(j + k) * dice::choose(i - 1, i - j - k) as usize;
            }

            count += x * dice::choose(conflict_size, j) as usize;
        }
    }

    // if no_conflict_size == 0 {
    //     count += slot_count;
    // }

    count
}

#[allow(unused_variables, dead_code)]
fn calc_gizmo_probabilities(data: &Data, args: &Args, invent_budgets: &Vec<Budget>, input_materials: &Vec<MaterialName>,
    wanted_gizmo: &Gizmo)
{
    todo!();
}